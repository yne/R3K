<!doctype HTML><html><body><style>h1{ page-break-before: always; }</style><div id="t" class="container" style="text-align:justify">
#Introduction :

Pour ce projet j'ai préféré travailler seul (comme sur tout les autres projets)
car cela me force a être autonome et a maitriser le projet de A à Z.
Je n'ai n'y essayé de faire au plus vite ni d'implémenter le plus de fonction possible,
mais plutôt de faire une architecture la plus optimisée et concise possible,
même si cela m'a forcé forcé à recommencer plusieurs fois (parfois de zéro).

Plutôt que de ré-expliquer la partie commune a tout les projet
(Qu'est-ce qu'un pipeline, un chemin de données, un aléa ...),
ce rapport se concentrera sur les points qui le différencie des autres
ainsi que les choix d'implémentations qui ont étaient fait et leur raisons.

La présentation des différents travaux réalisés sera répartie selon leur emplacement dans le chemin de données.
Enfin, nous terminerons, avec les travaux qui ne sont pas en rapport avec un étage spécifique.

> Ce projet a été synchronisé avec [github.com/yne/r3k](http://github.com/yne/r3k)
> il est donc possible d'en afficher toute les versions
> afin de voir en détail les différentes itérations que j'ai faites sur le code.

![pipeline risc](doc/pipeline.jpg)

# Etage EI

Cet étage contient que 3 entités (ei_pc_mux, reg_pc, icache).
Leurs rôles se limitent à modifier le PC et à fetcher depuis le cache d'instruction l'instruction pointée par le PC.

Le registre PC peut être modifié par plusieurs sources d'adresse :
- Son adresse suivante
- Adresse d'un saut par registre (JR/JALR)
- Adresse d'un saut par valeur immédiate (J/JAL)
- Adresse d'un branchement immédiat/par registre (B*)

J'ai décidé d'implémenter ces modifications au plus tôt dans le pipeline.
Les valeurs sont donc disponibles à différents étages dans le pipeline :
- CP+4 : disponible en **EI**
- JR/JALR : disponible en **DI**
- J/JAL : disponible en **DI**
- BNE,BLE... : disponible en **EX**


Il nous faut donc un mux avec plusieurs entrées et plusieurs flags en paramètre et qui prendrait l'adresse la plus avancée parmi toutes celles valides :

```VHDL
with(ei_pc_mux) select ei_pc_next <= 
	reg_PC(PC'range)+1 when PC_NEXT, -- "+" surchargé par l'entity adder
	di_pc_branch       when PC_BRANCH,-- BEQ,BNE,BLEZ,BGTZ,BLTZ,BGEZ,BLTZAL,BGEZAL
	ei_pc_jump         when PC_JUMP,  -- J/JAL
	di_qa(PC'range)    when PC_JUMP_R;-- JR/JALR
```

Voici l'agorithme de décision du chemin à emprunter :

```VHDL
ei_pc_mux <= PC_BRANCH when
   ((reg_EX_ME.me_ctrl.BRANCH=B_NE) and (not(reg_EX_ME.ual_Z='1')                                                    ))
or ((reg_EX_ME.me_ctrl.BRANCH=B_EQ) and (   (reg_EX_ME.ual_Z='1')                                                    ))
or ((reg_EX_ME.me_ctrl.BRANCH=B_LE) and (   (reg_EX_ME.ual_Z='1') or     (reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
or ((reg_EX_ME.me_ctrl.BRANCH=B_LT) and (not(reg_EX_ME.ual_Z='1') and    (reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
or ((reg_EX_ME.me_ctrl.BRANCH=B_GT) and (not(reg_EX_ME.ual_Z='1') and not(reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
or ((reg_EX_ME.me_ctrl.BRANCH=B_GE) and (   (reg_EX_ME.ual_Z='1') or  not(reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
else PC_JUMP   when di_ctrl_di.JUMP_IMM
else PC_JUMP_R when di_ctrl_di.JUMP_REG
else PC_NEXT;
```

On remarque que le cas du BRANCH est le plus prioritaire (car disponible tardivement en EX), suivi par les JUMP (disponible en DI) et en dernier le PC+4 si aucune des conditions précédentes n'est remplie.

# Etage DI

Au fur et à mesure que j'implémentais les différents op-codes de l'unité de contrôle,
j’avais la sensation grandissante que cette unité pouvait être factorisable
en fonction des bits des instructions qu'elle traitait.
Ce sont surtout les instructions SIGNED/UNSIGNED (avec seulement leurs derniers bits qui varient)
qui m'ont mis la puce à l'oreille.

A ma première tentative, l'unité de contrôle complète tenais dans (180 lignes).
Et voici la version après réécriture complète en 40 lignes (soit 5 fois plus légère):

```VHDL
di_ctrl_di <= DI_DEFL; -- IMM_UNSIGNED,'0','0'
di_ctrl_ex <= EX_DEFL; -- SUB,ALU_SIGNED,REGS_QA,REGS_QB,REG_RT
di_ctrl_me <= ME_DEFL; -- MEM_32,B_NULL,MEM_READ,MEM_UNSIGNED,'0'
di_ctrl_er <= ER_DEFL; -- REG_WRITE,ALU_S

if(OP=TYPE_R)then                  -- REG ARITHMETIC
	di_ctrl_di.JUMP_REG  <= '1'        when F=JR  or F=JALR;
	di_ctrl_ex.REG_DST   <= REG_RD;-- 
	di_ctrl_ex.ALU_SIGNED<= F(0);-- 1=unsigned
	di_ctrl_ex.ALU_SRCA  <= REGS_QB    when F=LSL or F=LSR;
	di_ctrl_ex.ALU_SRCB  <= VAL_DEC    when F=LSL or F=LSR;
	di_ctrl_er.REGS_SRCD <= NextPC     when F=JR  or F=JALR;
	di_ctrl_er.REGS_WE   <= REG_RDONLY when F=JR;
	di_ctrl_ex.ALU_OP    <= LSR        when F=JR  or F=JALR else F;
	if(f=SYNC)then report "BREAK INSTR" severity FAILURE;end if;
elsif(OP=TYPE_B)then               -- REG BRANCH
	di_ctrl_ex.ALU_SRCB   <= IMM_0;
	with(B) select di_ctrl_me.branch <= 
		B_LT when BLTZ|BLTZAL,B_GE when BGEZ|BGEZAL,B_NULL when others;
elsif OP(5 downto 4) = "10" then   -- MEMOIRE L*/S*
	di_ctrl_ex.REG_DST    <= REG_RD when OP(3)='1' else REG_RT;
	di_ctrl_me.DC_RW      <= OP(3);
	di_ctrl_me.DC_DS      <= OP(1 downto 0);
	di_ctrl_me.DC_SIGNED  <= OP(2);
	di_ctrl_er.REGS_WE    <= OP(3);
elsif OP(5 downto 3) = "001"  then -- IMM ARITHMETIC (REG_RT=REGS_QA <?> IMMD)
	di_ctrl_er.REGS_SRCD  <= ALU_S;
	di_ctrl_ex.ALU_SRCA   <= IMMD   when OP=LUI;
	di_ctrl_ex.ALU_SRCB   <= IMM_16 when OP=LUI else IMMD;
	di_ctrl_ex.ALU_SIGNED <= OP(0);-- 1=unsigned
	di_ctrl_di.SIGNED_EXT <= IMM_SIGNED when OP=ADDI or OP=ADDIU or OP=SLTI;
	di_ctrl_ex.ALU_OP <= OP;
elsif OP(5 downto 2) = "0001" then -- IMM BRANCH (JUMP_BRA = r[rs]<?>r[rt/0])
	with(OP) select di_ctrl_me.branch <=
		B_EQ when BEQ,B_NE when BNE,B_LE when BLEZ,	B_GT when BGTZ,B_NULL when others;
elsif OP(5 downto 1) = "00001" then -- JUMP (J/JAL)
	di_ctrl_di.JUMP_IMM <= '1';
	di_ctrl_er.REGS_WE <= REG_WRITE when OP = JAL else REG_RDONLY;
	di_ctrl_ex.REG_DST <= REG_31    when OP = JAL else REG_RD;
end if;
```

On remarque que :

- Les attributs les plus utilisés par les différents étages sont mis dans la valeur par défaut de l'étage (valeurs qui sont assignées dès le début de la fonction).
Ainsi, même si aucun ALU_OP n'est spécifié (comme dans les étages REG BRANCH_R et IMM BRANCH) c'est l'opération SUB qui sera effectuée (car la plus utilisée par l'ensemble des étages).
- Le choix du code opération de l'ALU est déporté dans l'ALU elle même (dont nous verrons en détail la raison dans le chapitre EX).
- Le code des instructions contient souvent les attributs à certain offset.
Par exemple, pour les instructions de type registre, on a les codes fonctions suivants :

| Name | Code     |
|------|----------|
| ADD  | `10000 0` |
| ADD**U** | `10000 1` |
| SUB  | `10001 0` |
| SUB**U** | `10001 1` |
| SLT  | `10101 0` |
| SLT**U** | `10101 1` |
| LSL  | `00000 0` |
| LSR  | `00001 0` |
| JR   | `00100 0` |
| JALR | `00100 1` |
| iAND | `10010 0` |
| iOR  | `10010 1` |
| iXOR | `10011 0` |
| iNOR | `10011 1` |

On remarque que le bit de poids faible des opérations arithmétiques contient le signe de l'opération (signed/unsigned).
On peut donc simplement écrire  `di_ctrl_ex.ALU_SIGNED<= F(0);` pour mettre l'attribut à la bonne valeur.

> Cela signifie que les autres instructions (sauts, opérations booléennes et opérations décalages) auront cet attribut de signe positionné a un étant qui ne leur correspond pas.
> Mais ces derniers ne prennent pas en compte cet attribut donc ce n'est pas un problème



Un exemple plus flagrant avec les instructions de type mémoires :

| Name | Code     |
|------|----------|
|LB    | `10 0 0 00` |
|LH    | `10 0 0 01` |
|LW    | `10 0 0 11` |
|LBU   | `10 0 1 00` |
|LHU   | `10 0 1 01` |
|SB    | `10 1 0 00` |
|SH    | `10 1 0 01` |
|SW    | `10 1 0 11` |

On remarque que les bits sont de la forme :

| Bits | Description | valeurs |
|----- |-------------|---------|
| 5-4  | toujours | `10` |
| 3    | Type  | `0`=Load, `1`=Store |
| 2    | Signe | `0`=signed, `1`=unsigned |
| 1-0  | Taille| nb d'octets `00`=1, `01`=2, `10`=3, `11`=4 |

Cette unité de contrôle est valide, et le processeur produit bien successivement les valeurs 0,1,-1,-1,2,-2,0 et 8 dans les registres.

```
00100000000000000000000000000001;ADDI  r0,0001=> r0
00100000000000010000000000000001;ADDI  r0,0001=> r1
00100000000000101111111111111111;ADDI  r0,FFFF=> r2
00100100000000111111111111111111;ADDIU r0,FFFF=> r3
00000000001000010010011111100000;ADD   r1,r1 => r4
00000000010000100010111111100001;ADDU  r2,r2 => r5
00000000000000000000000000000000;LSL   r0,0  => r0 (NOP)
00000011111000010011100011000000;LSL   r1,4  => r7
00000000000000000000000000000000;NOP
00000000000000000000000000000000;NOP
00000000000000000000000000000000;NOP
00000000000000000000000000001111;SYNC
00000000000000000000000000001000;JR    r0
```

![screen bench alu](doc/bench_alu.png)

Nous pouvons optimiser encore plus et directement envoyer la partie de l'instruction représentant la taille de l'accès mémoire en entrée de notre banc mémoire générique.
C'est ce qui est fait dans la ligne `di_ctrl_me.DC_DS <= OP(1 downto 0)`

Il serait possible d'optimiser encore plus l'unité en déportant le switch qui assigne le ALU_OP dans l'alu en créant un `ALU_CTRL` à coté de l'alu et en faisant suivre l'instruction jusqu'à
l'étage de l'ALU (EX) pour que l'ALU_CTRL fasse elle-même le switch pour déterminer l'opération.

# Etage EX

L'étage EX posede 1 ALU est 3 mux :

### MUX : ALU_SRC_A

Qui met en entrée A de l'ALU, les signaux :
- QA pour les opérations type registre (excepté LSL/LSR)
- QB pour les opérations LSL/LSR
- IMMD pour les opérations arithmétiques immédiates

### MUX : ALU_SRC_B

Qui met en entrée B de l'ALU, les signaux :
- QB : pour la plupart des opérations type registre
- IMM : pour toutes les opérations de type arithmétique à valeur immédiate
- VALDEC : pour les instructions LSL et LSR qui contiennent le nombre de décalage dans leur zone "valdec"
- 16 : pour l'instruction LUI qui nécessite un décalage à gauche de 16 bits
- 0 : pour les comparaisons type BNEZ (comparaison "QA vs 0")

> Il serait possible de diminuer le nombre d'entrée de ce mux (actuelement de 5)
> en redirigeant le mux vers le signal VALDEC qui contiendrait la valeur constante (0, 16) mise en place par l'unité de contrôle.
> Mais cela sous-entendrait que l'unité de contrôle aurait accès à ces signaux en "out" ce qui n'est pas le cas actuellement,
> et qui serait impossible sans ajouter une grande quantité de fil, alors que notre but est d'en économiser...

### MUX : REG_DST
Ce registre est en charge de définir le registre de destination où sera stocké le résultat (qui peut-être soit une lecture mémoire, la sortie de l'ALU, le prochain emplacement du PC)

### ALU

Comme nous l'avons vue précédemment, le contrôle de l'opération de l'ALU a été déplacé dans l'ALU elle-même.
La raison est simple, cela permet d'éviter 2 switch dans le code de l'unité de contrôle et de les combiner à la place du switch existant dans l'ALU.
L'ALU ne switchera donc plus sur ALU_OP mais sur l'OPCODE ou le FCODE de l'instruction :

```VHDL
when iAND|ANDI => tmp_S := A and B;
when iOR |ORI  => tmp_S := A  or B;
when iNOR      => tmp_S := A nor B;
when iXOR|XORI => tmp_S := A xor B;
when LSL |LUI  => tmp_S := shl(A,B);
when LSR       => tmp_S := shr(A,B);
```

> Les instructions type registre `JR` et `JALR` entre respectivement en conflit avec `ADDI` et `ADDIU`.
> Donc à la réception d'un `JR` l'ALU pensera avoir à faire à un `ADDI` or le JR doit faire effectuer un `LSR` à l'ALU.
> La solution est donc de ne pas envoyer le FCODE pour le `JR` et le `JALR` mais directement l'`LSR` :

```
di_ctrl_ex.ALU_OP    <= LSR        when F=JR  or F=JALR else F;
```

# Etage ME

Le registre mémoire a été l'une des premières entités sur laquelle j'ai compris qu'il y avait un potentiel d'optimisation.
J'ai donc décidé de la modifier pour qu'elle puisse accepter n'importe quel taille de donnée en entrée en utilisant un `natural` comme attribut du DS.
Puis, dans une seconde itération j'ai décidé de n'utiliser que des `std_logic_vector` car cela permettait de lui mettre en entrée directement les bits des opcodes sans avoir à passer par un `conv_integer`.

```VHDL
P_CACHE: process(CLK, RST, ADR, AS, RW, DS, SIGN) begin
if RST = '0' then 
	REGS <= (others=>(others=>(others=>'0'))) when STRING'(FILENAME)="" else LOAD_FILE(STRING'(FILENAME));
else
	if AS = '0' then
		Q <= (others => 'Z');
	else 
		if (DS/=MEM_8 and ADR(natural(log2(real(conv_integer(DS)+1)))-1 downto 0) /= ZERO)then
			Berr <= '0';
		else
			Berr <= '1';
			if RW = MEM_READ then 
				Q <= (others => '0');
				for i in 0 to conv_integer(DS) loop
					Q((i+1)*8 - 1 downto i*8) <= REGS(conv_integer(ADR(I_ADR'range)))(conv_integer(ADR(B_ADR'range))+i);
				end loop;
				if SIGN = MEM_SIGNED then
					Q(DBUS_WIDTH-1 downto (conv_integer(DS)+1)*8) <= (others=>REGS(conv_integer(ADR(I_ADR'range)))(conv_integer(ADR(B_ADR'range)) + conv_integer(DS))(0));
				end if;
			else -- MEM_WRITE
				if CLK'event and CLK=ACTIVE_FRONT then
					for i in 0 to (conv_integer(DS)) loop
						REGS(conv_integer(ADR(I_ADR'range)))(conv_integer(ADR(B_ADR'range)) + i) <= D((i+1) * 8 - 1 downto i*8);
					end loop;
				end if;
			end if;
		end if;
	end if;
end if;
end process;
```

Cette dernière modification permet à l'entité memory d'obtenir directement la taille à copier à partir du code de l'instruction : `di_ctrl_me.DC_DS <= OP(1 downto 0);`

# Etage ER

L'étage ER ne possède qu'un mux servant a rediriger la source du résultat (REGS_SRCD) vers le banc de registre.
Les différentes sources de résultats sont :
- PC : le prochain PC (utilisé pour stocker dans un registre, le plus souvent le 31, l'adresse de retour de la fonction)
- Q : sortie mémoire (opération de Load)
- S : sortie de l'UAL (la plupart des opérations en général)

```VHDL
er_adrw<=reg_ME_ER.reg_dst;
with(reg_ME_ER.er_ctrl.REGS_SRCD) select er_regd <= 
	reg_ME_ER.mem_Q        when MEM_Q,
	reg_ME_ER.ual_S        when ALU_S,
	conv_std_logic_vector(conv_integer(reg_ME_ER.pc_next), DATA'length)      when NextPC;
end behavior;
```
> Il doit y avoir un meilleur moyen d'arriver a maper deux std_logic_vector de taille différentes
> peut être en utilisant `my_vec & "00"` ?

La sortie du `MUX_SRCD` est stoquée dans la banc de registre indiqué par `REG_W` a condition que `er_reg_w` autoriser l'ecriture dans le bac.

> Une optimisation possible serait de se passer totalement du `er_reg_w` et de laisser toujours l'ecriture possible
> et de pointer `REG_W` vers `R0` lorsque l'on ne veu pas ecrire le resultat dans un registre
> puisque le registre `R0` registre reste a 0 quoi que l'on y ecrive.

# Ajout de l'instruction SYNC

Je trouvais frustrant de ne pas avoir de contrôle sur l'arrêt de la simulation autre que le timeout,
j'ai donc décidé d'ajouter une instruction SYNC (famille des instructions TYPE_R, FCODE=001111)
Cette instruction provoque le code VHDL suivant :

 
```VHDL
if(f=SYNC)then
    report "BREAK INSTR" severity FAILURE;
end if;
```

![screen synch stop](doc/sync_exec.png)

Cela permet de mettre un terme à la simulation proprement (à l'image d'un exit() en C).

# IEEE.math_real.log2

J'ai supprimé toute trace de la fonction `cpu_package.log2` au profit de la librairie `IEEE.math_real.log2` car :
- Si ça existe déjà, pourquoi alourdir le code avec des fonctions doublon ?
- elle est surement bien faite (c'est l'IEEE quand même !)

# JS-ASM

Pour m'occuper (et parce-que M Thiebolt nous avais proposé de le faire)
j'ai décidé de créer mon propre assembleur R3000 en me basant sur un de mes anciens projets d'assembleur MIPS.
Le résulta est un assembleur codé en langage web capable de générer du code à la volée (génération en parallèle de la saisie de l'utilisateur)
Sa force réside dans le fait qu'il est syntaxiquement beaucoup moins strict que l'assembleur *r3kasm2* mais il ne gère pas (encore) les labels.

![screen synch stop](doc/js-asm.png)

# VHDL 2 GRAPH

Pour m'aider lors de la conception du R3K j'utilisais très souvent le schémas du pipeline fourni par M Thiebolt.
Mais pour vérifier que mon code suivait bien mes dessins, je devais faire de fastidieuses vérifications de code.
J'ai donc décidé de faire un outil capable de régénérer le graphique des étages du pipeline directement à partir du code source `risc.vhd`
Le résultat est assez impressionnant et plus satisfaisant que je ne l'espérais :

![screen risc graph](doc/risc-graph.png)

# Conclusion

Même si je n'ai pas tout fait (cache,envoie,...) je me suis bien amusé sur ce projet.
Cela a été pour moi un excellent exercice qui m'a permis de bien maitriser VHDL
(ce qui pour moi etais un des objectifs principaux de ce projet)
ainsi que l'outil ModelSim que l'on adore détester mais qui au final s'est avéré être extrêmement puissant et personnalisable.

# Annexes

### [cpu_package](cpu_package.vhd)

```VHDL
--------------------------------------------------------------------------------
-- RISC processor general definitions
-- THIEBOLT Francois le 08/03/14
--------------------------------------------------------------------------------

library IEEE;

use IEEE.math_real.log2;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use work.func_package.all;

package cpu_package is

-- ===============================================================
-- TYPES/CONSTANT DEFINITIONS
-- ===============================================================

------------------------------------------------------------------
-- HARDWARE definitions
------------------------------------------------------------------
-- define CPU core physical sizes
	constant CPU_DATA_WIDTH : positive := 32; -- data bus width
	constant CPU_INST_WIDTH : positive := CPU_DATA_WIDTH; -- instruction bus width
	constant CPU_ADR_WIDTH  : positive := 32; -- address bus width, byte format

-- define MISC CPU CORE specs
	constant CPU_WR_FRONT   : std_logic:= '1';-- pipes write active front
	constant PC_WIDTH       : positive := 26;-- bits pour le PC format mot memoire
	constant PCLOW          : positive := natural(log2(real(CPU_INST_WIDTH/8)));

-- define REGISTERS physical sizes
	constant REG_WIDTH      : positive := 5; -- registers address bus with
	constant REG_FRONT      : std_logic:= CPU_WR_FRONT;

-- define instruction & data CACHE physical sizes
	constant L1_SIZE        : positive := 32; -- taille des caches L1 en nombre de mots
	constant L1_ISIZE       : positive := L1_SIZE; -- taille du cache instruction L1 en nombre de mots
	constant L1_DSIZE       : positive := L1_SIZE; -- taille du cache donnees L1 en nombre de mots
	constant L1_FRONT       : std_logic:= CPU_WR_FRONT;

-- define types/subtypes according to hardware specs
	subtype PC          is std_logic_vector(PC_WIDTH-1+PCLOW downto PCLOW);
	subtype INST        is std_logic_vector(CPU_INST_WIDTH-1 downto 0);
	subtype ADDR        is std_logic_vector(CPU_ADR_WIDTH-1 downto 0);
	subtype DATA        is std_logic_vector(CPU_DATA_WIDTH-1 downto 0);
	subtype REGS        is std_logic_vector(REG_WIDTH-1 downto 0);

-- define default values
	constant PC_DEFL : ADDR := conv_std_logic_vector( 0,ADDR'length);
	constant ZERO    : DATA := conv_std_logic_vector( 0,DATA'length);
	constant VAL16   : DATA := conv_std_logic_vector(16,DATA'length);

------------------------------------------------------------------
-- SOFTWARE definitions
------------------------------------------------------------------
-- [_OP_][________________________]
-- 000000[RS_][RT_][RD_][VAL][FCOD] TYPE_R
-- 000001[RS_][BCO][_____IMM______] TYPE_B
-- 00001X[__________JADR__________] TYPE_J
-- 001XXX[RS_][RT_][_____IMM______] TYPE_I
-- 10WUSS[RS_][RT_][_____IMM______] TYPE_M Write/Unsigned/Size
-- definition des champs d'instructions
	subtype OPCODE    is std_logic_vector(31 downto 26);
	subtype RS        is std_logic_vector(25 downto 21);
	subtype RT        is std_logic_vector(20 downto 16);
	subtype RD        is std_logic_vector(15 downto 11);
	subtype VALDEC    is std_logic_vector(10 downto  6);
	subtype FCODE     is std_logic_vector( 5 downto  0);
	
	subtype BCODE     is std_logic_vector(20 downto 16);
	subtype IMM       is std_logic_vector(15 downto  0);
	subtype JADR      is std_logic_vector(25 downto  0);

-- ===== INSTRUCTIONS =====
	constant TYPE_R     : std_logic_vector := "000000" ;
	    constant LSL    : std_logic_vector := "000000" ;--r[rd]=  r[rt]<< re;
	    constant LSR    : std_logic_vector := "000010" ;--r[rd]=  u[rt]>> re;
	    constant JR     : std_logic_vector := "001000" ;--                  s->pc_next=r[rs];
	    constant JALR   : std_logic_vector := "001001" ;--r[rd]=s->pc_next; s->pc_next=r[rs];
	    constant ADD    : std_logic_vector := "100000" ;--r[rd]=  r[rs] + r[rt];
	    constant ADDU   : std_logic_vector := "100001" ;--r[rd]=  r[rs] + r[rt];
	    constant SUB    : std_logic_vector := "100010" ;--r[rd]=  r[rs] - r[rt];
	    constant SUBU   : std_logic_vector := "100011" ;--r[rd]=  r[rs] - r[rt];
	    constant iAND   : std_logic_vector := "100100" ;--r[rd]=  r[rs] & r[rt];
	    constant iOR    : std_logic_vector := "100101" ;--r[rd]=  r[rs] | r[rt];
	    constant iXOR   : std_logic_vector := "100110" ;--r[rd]=  r[rs] ^ r[rt];
	    constant iNOR   : std_logic_vector := "100111" ;--r[rd]=~(r[rs] | r[rt]);
	    constant SLT    : std_logic_vector := "101010" ;--r[rd]=  r[rs] < r[rt];
	    constant SLTU   : std_logic_vector := "101011" ;--r[rd]=  u[rs] < u[rt];
	    constant SYNC   : std_logic_vector := "001111" ;--ALLOW US TO BREAK
	
	constant TYPE_B     : std_logic_vector := "000001" ;
	    constant BLTZ   : std_logic_vector :=  "00000" ;--branch=r[rs]<0;
	    constant BGEZ   : std_logic_vector :=  "00001" ;--branch=r[rs]>=0;
	    constant BLTZAL : std_logic_vector :=  "10000" ;--r[31]=s->pc_next; branch=r[rs]<0;
	    constant BGEZAL : std_logic_vector :=  "10001" ;--r[31]=s->pc_next; branch=r[rs]>=0;
	
	constant J          : std_logic_vector := "000010" ;--                  s->pc_next=(s->pc&0xf0000000)|target;
	constant JAL        : std_logic_vector := "000011" ;--r[31]=s->pc_next; s->pc_next=(s->pc&0xf0000000)|target;
	
	constant BEQ        : std_logic_vector := "000100" ;--branch=r[rs]==r[rt];
	constant BNE        : std_logic_vector := "000101" ;--branch=r[rs]!=r[rt];
	constant BLEZ       : std_logic_vector := "000110" ;--branch=r[rs]<=0;
	constant BGTZ       : std_logic_vector := "000111" ;--branch=r[rs]>0;
	
	constant ADDI       : std_logic_vector := "001000" ;--r[rt]=r[rs]+(short)imm;
	constant ADDIU      : std_logic_vector := "001001" ;--u[rt]=u[rs]+(short)imm;
	constant SLTI       : std_logic_vector := "001010" ;--r[rt]=r[rs]<(short)imm;
	constant SLTIU      : std_logic_vector := "001011" ;--u[rt]=u[rs]<(unsigned long)(short)imm;
	constant ANDI       : std_logic_vector := "001100" ;--r[rt]=r[rs]&imm;
	constant ORI        : std_logic_vector := "001101" ;--r[rt]=r[rs]|imm;
	constant XORI       : std_logic_vector := "001110" ;--r[rt]=r[rs]^imm;
	constant LUI        : std_logic_vector := "001111" ;--r[rt]=(imm<<16);
	
	constant LB         : std_logic_vector := "100000" ;--r[rt]=*(signed char*)ptr;
	constant LH         : std_logic_vector := "100001" ;--r[rt]=*(signed short*)ptr;
	constant LW         : std_logic_vector := "100011" ;--r[rt]=*(long*)ptr;
	constant LBU        : std_logic_vector := "100100" ;--r[rt]=*(unsigned char*)ptr;
	constant LHU        : std_logic_vector := "100101" ;--r[rt]=*(unsigned short*)ptr;
	
	constant SB         : std_logic_vector := "101000" ;--*(char*)ptr=(char)r[rt];
	constant SH         : std_logic_vector := "101001" ;--*(short*)ptr=(short)r[rt];
	constant SW         : std_logic_vector := "101011" ;--*(long*)ptr=r[rt];
	
	type     B_OPS is (B_NULL  ,  B_EQ,B_NE,B_LE,B_GT  ,  B_LT,B_GE);
	--type     ALU_OPS is (ALU_UNK,ALU_ADD,ALU_SUB,ALU_AND,ALU_OR,ALU_NOR,ALU_XOR,ALU_SLT,ALU_LSL,ALU_LSR);
	constant ALU_SIGNED  : std_logic := '0';
	constant ALU_UNSIGNED: std_logic := '1';
	constant IMM_UNSIGNED: std_logic := '0';
	constant IMM_SIGNED  : std_logic := '1';

	constant MEM_8  : std_logic_vector := "00" ;
	constant MEM_16 : std_logic_vector := "01" ;
	constant MEM_32 : std_logic_vector := "11" ;
	constant MEM_READ      : std_logic := '0' ;
	constant MEM_WRITE     : std_logic := '1' ;
	constant MEM_SIGNED    : std_logic := '0' ;
	constant MEM_UNSIGNED  : std_logic := '1' ;
	
	constant REG_WRITE     : std_logic := '0' ;
	constant REG_RDONLY    : std_logic := '1' ;

------------------------------------------------------------------
-- HARDWARE Multiplexer and Pipelines registers definitions
------------------------------------------------------------------

---------------------------------------------------------------
-- Definition des multiplexeurs dans les etages
	type MUX_ALU_A   is (REGS_QA,IMMD,REGS_QB);
	type MUX_ALU_B   is (REGS_QB,IMMD,VAL_DEC,IMM_0,IMM_16);
	type MUX_REG_DST is (REG_RT,REG_RD,REG_31);
	type MUX_REGS_D  is (ALU_S,MEM_Q,NextPC);
	type MUX_PC_SRC  is (PC_NEXT,PC_BRANCH,PC_JUMP,PC_JUMP_R);

-- STRUCTURES DE CONTROLES DES ETAGES

	type ctrlDI is record
		SIGNED_EXT     : std_logic;-- extension signee ou non donnee immediate
		JUMP_IMM       : std_logic;
		JUMP_REG       : std_logic;
	end record;

	type ctrlEX is record
		ALU_OP      : FCODE;    -- ALU_ADD,ALU_SUB,ALU_AND,ALU_OR,ALU_NOR,ALU_XOR,ALU_SLT,ALU_LSL,ALU_LSR
		ALU_SIGNED  : std_logic;   -- operation ALU signee ou non
		ALU_SRCA    : MUX_ALU_A;  -- REGS_QA,REGS_QB,IMMD
		ALU_SRCB    : MUX_ALU_B;  -- REGS_QB,IMMD,VAL_DEC
		REG_DST     : MUX_REG_DST;-- REG_RD,REG_RT,REG_31
	end record;

	type ctrlME is record
		DC_DS       : std_logic_vector (1 downto 0);   -- DataCache taille d'acces 8/16/32/64/...
		BRANCH      : B_OPS ;     -- BRANCHE TYPE
		DC_RW       : std_logic;  -- DataCache signal R/W*
		DC_AS       : std_logic;  -- DataCache signal Address Strobe
		DC_SIGNED   : std_logic;  -- DataCache operation signee ou non (lecture)
	end record;
	
	type ctrlER is record
		REGS_WE     : std_logic; -- REG_RDONLY/ REG_WRITE
		REGS_SRCD   : MUX_REGS_D;-- ALU_S,MEM_Q,NextPC
	end record;
	
	constant DI_DEFL : ctrlDI := ( IMM_UNSIGNED,'0','0');
	constant EX_DEFL : ctrlEX := ( SUB,ALU_SIGNED,REGS_QA,REGS_QB,REG_RT);
	constant ME_DEFL : ctrlME := ( MEM_32,B_NULL,MEM_READ,MEM_UNSIGNED,'0');
	constant ER_DEFL : ctrlER := ( REG_WRITE,ALU_S);

-- STRUCURES DES REGISTRES PIPELINE
	type EI_DI is record
-- === Data ===
		pc_next     : std_logic_vector (PC  'range);-- cp incremente
		inst        : std_logic_vector (INST'range);-- instruction extraite
-- === Control ===
	end record;
	type DI_EX is record
-- === Data ===
		pc_next     : std_logic_vector (PC'range);-- cp incremente propage
		rs          : std_logic_vector (REGS'range);-- champ rs
		rt          : std_logic_vector (REGS'range);-- champ rt
		rd          : std_logic_vector (REGS'range);-- champ rd
		val_dec     : std_logic_vector (VALDEC'range);-- valeur de decalage
		imm_ext     : std_logic_vector (DATA'range);-- valeur immediate etendue
		jump_adr    : std_logic_vector (JADR'RANGE);-- champ adresse de JUMP_IMMs
		rs_read     : std_logic_vector (DATA'range);-- donnee du registre lu rs
		rt_read     : std_logic_vector (DATA'range);-- donnee du registre lu rt
		val_ext     : std_logic_vector (DATA'range);-- valdec etendu
-- === Control ===
		ex_ctrl     : ctrlEX;-- signaux de control de l'etage EX
		me_ctrl     : ctrlME;-- signaux de control de l'etage MEM
		er_ctrl     : ctrlER;-- signaux de control de l'etage ER
	end record;

-- Structure du registre EX/MEM
	type EX_ME is record
-- === Data ===
		pc_next     : std_logic_vector (PC'range);-- cp incremente propage
		ual_S       : std_logic_vector (DATA'range);-- resultat ual
		ual_N       : std_logic;-- resultat ual
		ual_V       : std_logic;-- resultat ual
		ual_Z       : std_logic;-- resultat ual
		ual_C       : std_logic;-- resultat ual
		rt_read     : std_logic_vector (DATA'range);-- registre rt propage
		reg_dst     : std_logic_vector (REGS'range);-- registre destination (MUX_REG_DST)
-- === Control ===
		me_ctrl     : ctrlME;-- signaux de control de l'etage MEM
		er_ctrl     : ctrlER;-- signaux de control de l'etage ER
	end record;

-- Structure du registre MEM/ER
	type ME_ER is record
-- Signaux
		pc_next     : std_logic_vector (PC'range);-- cp incremente propage
		mem_Q       : std_logic_vector (DATA'range);-- sortie memoire
		ual_S       : std_logic_vector (DATA'range);-- resultat ual propage
		reg_dst     : std_logic_vector (REGS'range);-- registre destination propage
-- === Control ===
		er_ctrl			: ctrlER;-- signaux de control de l'etage ER propage
	end record;

-- ===============================================================
-- DEFINITION DE FONCTIONS/PROCEDURES
-- ===============================================================

-- Si on ne specifie rien devant les parametres...il considere que c'est une variable
-- exemple : procedure adder_cla (A,B: in std_logic_vector;...)
-- ici A et B sont consideres comme etant des variables...
-- Sinon il faut : procedure adder_cla (signal A,B: in std_logic_vector;...)

-- Fonction "+" --> procedure adder_cla
	function "+" (A,B: in std_logic_vector) return std_logic_vector;

-- Procedure adder_cla
	procedure adder_cla (A,B: in std_logic_vector; C_IN : in std_logic;
								S : out std_logic_vector; C_OUT : out std_logic;
								V : out std_logic);

-- Procedure alu
-- 	on notera l'utilisation d'un signal comme parametres formels de type OUT
	procedure alu (A,B: in std_logic_vector; signal S: out std_logic_vector;
						signal N,V,Z,C: out std_logic; SIGNED_OP: in std_logic;
						CTRL_ALU: in FCODE);

-- Procedure control
--		permet de positionner les signaux de control pour chaque etage (EX MEM ER)
--		en fonction de l'instruction identifiee soit par son code op, soit par
--		son code fonction, soit par son code branchement.
	procedure control ( OP : in std_logic_vector(OPCODE'length-1 downto 0);
	                    F  : in std_logic_vector(FCODE'length-1 downto 0);
	                    B  : in std_logic_vector(BCODE'length-1 downto 0);
	                    signal di_ctrl_di : out ctrlDI;-- signaux de controle de l'etage DI
	                    signal di_ctrl_ex : out ctrlEX;-- signaux de controle de l'etage EX
	                    signal di_ctrl_me : out ctrlME;-- signaux de controle de l'etage MEM
	                    signal di_ctrl_er : out ctrlER );-- signaux de controle de l'etage ER

end cpu_package;

-- -----------------------------------------------------------------------------
-- the package contains types, constants, and function prototypes
-- -----------------------------------------------------------------------------
package body cpu_package is

-- ===============================================================
-- DEFINITION DE FONCTIONS/PROCEDURES
-- ===============================================================

-- fonction "+" --> procedure adder_cla
function "+" (A,B: in std_logic_vector) return std_logic_vector is
	variable tmp_S : std_logic_vector(A'range);
	variable tmp_COUT,tmp_V : std_logic;
begin
	adder_cla(A,B,'0',tmp_S,tmp_COUT,tmp_V);
	return tmp_S;
end "+";

-- Le drapeau overflow V ne sert que lors d'operations signees !!!
-- Overflow V=1 si operation signee et :
--		addition de deux grands nombres positifs dont le resultat < 0
--		addition de deux grands nombres negatifs dont le resultat >= 0
--		soustraction d'un grand nombre positif et d'un grand nombre negatif dont le resultat < 0
--		soustraction d'un grand nombre negatif et d'un grand nombre positif dont le resultat >= 0
--	Reviens a faire V = C_OUT xor <carry entrante du dernier bit>
-- procedure adder_cla
procedure adder_cla (
	A,B: in std_logic_vector;C_IN : in std_logic;
	S : out std_logic_vector;C_OUT : out std_logic;
	V : out std_logic
) is
	variable G_CLA,P_CLA  : std_logic_vector(A'length-1 downto 0);
	variable C_CLA        : std_logic_vector(A'length downto 0);
begin
-- calcul de P et G
	G_CLA:= A and B;
	P_CLA:= A or B;
	C_CLA(0):=C_IN;
	for I in 0 to (A'length-1) loop
		C_CLA(I+1):= G_CLA(I) or (P_CLA(I) and C_CLA(I));
	end loop;
-- mise a jour des sorties
	S:=(A Xor B) xor C_CLA(A'length-1 downto 0);
	C_OUT:=C_CLA(A'length);
	V:= C_CLA(A'length) xor C_CLA(A'length - 1);
end adder_cla;

-- procedure alu
procedure alu (A,B: in std_logic_vector;signal S: out std_logic_vector;
					signal N,V,Z,C: out std_logic;SIGNED_OP: in std_logic;
					CTRL_ALU: in FCODE) is
	variable DATA_WIDTH : positive := A'length;
	variable b_in       : std_logic_vector(DATA_WIDTH-1 downto 0);
	variable c_in       : std_logic;
	variable tmp_S      : std_logic_vector(DATA_WIDTH-1 downto 0);
	variable tmp_V      : std_logic;
	variable tmp_N      : std_logic;
	variable tmp_C      : std_logic;
	variable tmp_CLA_C  : std_logic;
	variable tmp_CLA_V  : std_logic;
begin
-- raz signaux
	tmp_V := '0';
	tmp_N := '0';
	tmp_C := '0';
-- case sur le type d'operation
	case CTRL_ALU is
		when ADD|ADDU|ADDI|ADDIU | SUB|SUBU | SLT|SLTU|SLTI|SLTIU => -- ALU_ADD | ALU_SUB | ALU_SLT
			b_in := B;
			c_in := '0';
			if ((CTRL_ALU/=ADD)and(CTRL_ALU/=ADDU)and(CTRL_ALU/=ADDI)and(CTRL_ALU/=ADDIU)) then
				b_in := not(B);
				c_in := '1';
			end if;
			adder_cla(A,b_in,c_in,tmp_S,tmp_C,tmp_V);
			if (CTRL_ALU=SLT or CTRL_ALU=SLTU) then
				tmp_S := conv_std_logic_vector( (SIGNED_OP and (tmp_V xor tmp_S(DATA_WIDTH-1))) or (not(SIGNED_OP) and not(tmp_C)) , S'length );
-- remize ? 0 des flags selon definition
				tmp_C := '0';
				tmp_V := '0';
			else
				tmp_C := not(SIGNED_OP) and tmp_C;
				tmp_N := SIGNED_OP and tmp_S(DATA_WIDTH-1);
				tmp_V := SIGNED_OP and tmp_V;
			end if;
		when iAND|ANDI => tmp_S := A and B;
		when iOR |ORI  => tmp_S := A  or B;
		when iNOR      => tmp_S := A nor B;
		when iXOR|XORI => tmp_S := A xor B;
		when LSL |LUI  => tmp_S := shl(A,B);
		when LSR       => tmp_S := shr(A,B);
		when others =>
	end case;
-- affectation de la sortie
	S <= tmp_S;
-- affectation du drapeau Z (valable dans tous les cas)
	if (tmp_S=conv_std_logic_vector(0,DATA_WIDTH))
	then Z <= '1';
	else Z <= '0';
	end if;
-- affectation des autres drapeaux N,V,C
	C <= tmp_C;
	N <= tmp_N;
	V <= tmp_V;
end alu;

-- === Procedure control =========================================
-- Permet de positionner les signaux de control pour chaque etage (EX MEM ER)
-- en fonction de l'instruction identifiee soit par :
-- -> son code op
-- -> son code fonction
-- -> code branchement.
procedure control ( OP : in std_logic_vector(OPCODE'length-1 downto 0);
							F : in std_logic_vector(FCODE'length-1 downto 0);
							B : in std_logic_vector(BCODE'length-1 downto 0);
							signal di_ctrl_di	: out ctrlDI;
							signal di_ctrl_ex	: out ctrlEX;
							signal di_ctrl_me	: out ctrlME;
							signal di_ctrl_er	: out ctrlER ) is
begin
-- Initialisation
	di_ctrl_di <= DI_DEFL; -- IMM_UNSIGNED,'0','0'
	di_ctrl_ex <= EX_DEFL; -- SUB,ALU_SIGNED,REGS_QA,REGS_QB,REG_RT
	di_ctrl_me <= ME_DEFL; -- MEM_32,B_NULL,MEM_READ,MEM_UNSIGNED,'0'
	di_ctrl_er <= ER_DEFL; -- REG_WRITE,ALU_S

	if(OP=TYPE_R)then                  -- REG ARITHMETIC
		di_ctrl_di.JUMP_REG  <= '1'        when F=JR  or F=JALR;
		di_ctrl_ex.REG_DST   <= REG_RD;-- 
		di_ctrl_ex.ALU_SIGNED<= F(0);-- 1=unsigned
		di_ctrl_ex.ALU_SRCA  <= REGS_QB    when F=LSL or F=LSR;
		di_ctrl_ex.ALU_SRCB  <= VAL_DEC    when F=LSL or F=LSR;
		di_ctrl_er.REGS_SRCD <= NextPC     when F=JR  or F=JALR;
		di_ctrl_er.REGS_WE   <= REG_RDONLY when F=JR;
		di_ctrl_ex.ALU_OP    <= LSR        when F=JR  or F=JALR else F;-- JR=ADDI, JALR=ADDIU
		if(f=SYNC)then report "BREAK INSTR" severity FAILURE;end if;
	elsif(OP=TYPE_B)then               -- REG BRANCH
		di_ctrl_ex.ALU_SRCB   <= IMM_0;
		with(B) select di_ctrl_me.branch <= 
			B_LT when BLTZ|BLTZAL,B_GE when BGEZ|BGEZAL,B_NULL when others;
	elsif OP(5 downto 4) = "10" then   -- MEMOIRE L*/S*
		di_ctrl_ex.REG_DST    <= REG_RD when OP(3)='1' else REG_RT;
		di_ctrl_me.DC_RW      <= OP(3);
		di_ctrl_me.DC_DS      <= OP(1 downto 0);
		di_ctrl_me.DC_SIGNED  <= OP(2);
		di_ctrl_er.REGS_WE    <= OP(3);
	elsif OP(5 downto 3) = "001"  then -- IMM ARITHMETIC (REG_RT=REGS_QA <?> IMMD)
		di_ctrl_er.REGS_SRCD  <= ALU_S;
		di_ctrl_ex.ALU_SRCA   <= IMMD   when OP=LUI;
		di_ctrl_ex.ALU_SRCB   <= IMM_16 when OP=LUI else IMMD;
		di_ctrl_ex.ALU_SIGNED <= OP(0);-- 1=unsigned
		di_ctrl_di.SIGNED_EXT <= IMM_SIGNED when OP=ADDI or OP=ADDIU or OP=SLTI;
		di_ctrl_ex.ALU_OP <= OP;
	elsif OP(5 downto 2) = "0001" then -- IMM BRANCH (JUMP_BRA = r[rs]<?>r[rt/0])
		with(OP) select di_ctrl_me.branch <=
			B_EQ when BEQ,B_NE when BNE,B_LE when BLEZ,	B_GT when BGTZ,B_NULL when others;
	elsif OP(5 downto 1) = "00001" then -- JUMP (J/JAL)
		di_ctrl_di.JUMP_IMM <= '1';
		di_ctrl_er.REGS_WE <= REG_WRITE when OP = JAL else REG_RDONLY;
		di_ctrl_ex.REG_DST <= REG_31    when OP = JAL else REG_RD;
	end if;
end control;
end cpu_package;

```
### [memory](memory.vhd)

```VHDL

library IEEE;
library STD;
library WORK;

use IEEE.math_real.log2;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use IEEE.std_logic_textio.all;
use STD.textio.all;
use WORK.cpu_package.all;

-- Definition de l'entite
entity memory is

	-- definition des parametres generiques
	generic	(
		DBUS_WIDTH   : natural   := 32;-- largeur du bus de donnees par defaut
		ABUS_WIDTH   : natural   := 32;-- largeur du bus adr par defaut
		MEM_SIZE     : natural   := 16;-- nombre d'elements dans le cache exprime en nombre de mots
		ACTIVE_FRONT : std_logic := '1';-- front actif par defaut
		FILENAME     : string    := "" -- fichier d'initialisation
	);

	-- definition des entrees/sorties
	port 	(
		-- signaux de controle du cache
		RST       : in std_logic;  -- actifs a l'etat bas
		CLK       : in std_logic;
		RW        : in std_logic;  -- WRITE_ENABLE
		DS        : in std_logic_vector;    -- acces octet, demi-mot, mot...
		SIGN      : in std_logic;  -- extension de signe
		AS        : in std_logic;  -- Address Strobe (sorte de CS*)
		Ready     : out std_logic;  -- indicateur HIT/MISS
		Berr      : out std_logic;  -- bus error (acces non aligne par exemple), active low

		-- bus d'adresse du cache
		ADR			: in std_logic_vector(ABUS_WIDTH-1 downto 0);

		-- Ports entree/sortie du cache
		D				: in std_logic_vector(DBUS_WIDTH-1 downto 0);
		Q				: out std_logic_vector(DBUS_WIDTH-1 downto 0)
	);

end memory;

-- Definition de l'architecture du banc de registres
architecture behavior of memory is

	-- definition de constantes
	constant BITS_FOR_BYTES : natural := natural(log2(real(DBUS_WIDTH/8))) ; -- nb bits adr pour acceder aux octets d'un mot
	constant BITS_FOR_WORDS : natural := natural(log2(real(MEM_SIZE))) ; -- nb bits adr pour acceder aux mots du cache
	constant BYTES_PER_WORD : natural := DBUS_WIDTH/8 ; -- nombre d'octets par mot

	-- definitions de types (index type default is integer)
	subtype BYTE is std_logic_vector(7 downto 0); -- definition d'un octet
	type WORD is array (0 to BYTES_PER_WORD-1) of BYTE; -- definition d'un mot compose d'octets

	type FILE_REGS is array (0 to MEM_SIZE-1) of WORD;
	subtype I_ADR is std_logic_vector((BITS_FOR_WORDS + BITS_FOR_BYTES - 1) downto BITS_FOR_BYTES); -- internal ADR au format mot du cache
	subtype B_ADR is std_logic_vector(BITS_FOR_BYTES-1 downto 0); -- byte ADR pour manipuler les octets dans le mot
	subtype byte_adr is natural range 0 to BYTES_PER_WORD-1; -- manipulation d'octets dans les mots

	-- definition de la fonction de chargement d'un fichier
	--		on peut egalement mettre cette boucle dans le process qui fait les ecritures
	impure function LOAD_FILE (F : in string) return FILE_REGS is
		variable temp_REGS : FILE_REGS;
		file mon_fichier : TEXT open READ_MODE is STRING'(F); -- VHDL93 compliant
		--	file mon_fichier : TEXT is in STRING'(F); -- older implementation
		variable line_read : line := null;
		variable line_value : std_logic_vector (DBUS_WIDTH-1 downto 0);
		variable index,i : natural := 0;
	begin
		-- lecture du fichier
		index:=0;
		while (not ENDFILE(mon_fichier) and (index < MEM_SIZE))
		loop
			readline(mon_fichier,line_read);
			read(line_read,line_value);
			for i in 0 to BYTES_PER_WORD-1 loop
				temp_REGS(index)(i):=line_value(((i+1)*8)-1 downto i*8);
			end loop;
			index:=index+1;
		end loop;
		-- test si index a bien parcouru toute la memoire
		if (index < MEM_SIZE) then
			temp_REGS(index to MEM_SIZE-1):=(others => (others => (others => '0')));
		end if;
		-- renvoi du resultat
		return temp_REGS;
	end LOAD_FILE;

	signal REGS : FILE_REGS; -- le banc memoire

begin

Ready <= '1'; -- car pas encore un cache


P_CACHE: process(CLK, RST, ADR, AS, RW, DS, SIGN) begin
	if RST = '0' then 
		REGS <= (others=>(others=>(others=>'0'))) when STRING'(FILENAME)="" else LOAD_FILE(STRING'(FILENAME));
	else
		if AS = '0' then
			Q <= (others => 'Z');
		else 
			if (DS /= MEM_8 and ADR(natural(log2(real(conv_integer(DS)+1)))-1 downto 0) /= ZERO)then -- 16b:*0, 32b:*00 down to 0
				Berr <= '0';
			else
				Berr <= '1';
				if RW = MEM_READ then 
					Q <= (others => '0');
					for i in 0 to conv_integer(DS) loop -- nombre de bit a copier + 1 : 0 1 3 -> 1 2 4
						Q((i+1)*8 - 1 downto i*8) <= REGS(conv_integer(ADR(I_ADR'range)))(conv_integer(ADR(B_ADR'range)) + i);
					end loop;
					if SIGN = MEM_SIGNED then
						Q(DBUS_WIDTH - 1 downto (conv_integer(DS)+1) * 8) <= (others => REGS(conv_integer(ADR(I_ADR'range)))(conv_integer(ADR(B_ADR'range)) + conv_integer(DS))(0));
					end if;
				else -- MEM_WRITE
					if CLK'event and CLK=ACTIVE_FRONT then
						for i in 0 to (conv_integer(DS)) loop
							REGS(conv_integer(ADR(I_ADR'range)))(conv_integer(ADR(B_ADR'range)) + i) <= D((i+1) * 8 - 1 downto i*8);
						end loop;
					end if;
				end if;
			end if;
		end if;
	end if;
end process;

end behavior;
```

### [registres](registres.vhd)

```VHDL
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use WORK.cpu_package.all;

entity registres is
	generic	(-- definition des parametres generiques
		DBUS_WIDTH   : integer   := 32; -- largeur du bus de donnees par defaut
		ABUS_WIDTH   : integer   := 5;  -- largeur du bus adr pour acces registre soit 32 (2**5) par defaut
		ACTIVE_FRONT : std_logic := '1' -- definition du front actif d'ecriture par defaut
	);
	port 	(-- definition des entrees/sorties
		CLK,RST,W         : in  std_logic;
		ADR_A,ADR_B,ADR_W : in  std_logic_vector(ABUS_WIDTH-1 downto 0);
		D                 : in  std_logic_vector(DBUS_WIDTH-1 downto 0);
		QA,QB             : out std_logic_vector(DBUS_WIDTH-1 downto 0)
	);
end registres;

-------------------------------------------------------------------------------
-- REGISTRES architecture
-------------------------------------------------------------------------------

architecture behavior of registres is
	type FILE_REGS is array (0 to (2**ABUS_WIDTH)-1) of std_logic_vector (DBUS_WIDTH-1 downto 0);
	signal REGS : FILE_REGS; -- le banc de registres
begin

QA <= 
	(others => 'X') when is_x(ADR_A) else -- X si adresse invalide
	(others => '0') when conv_integer(ADR_A)=0 else -- 0 si R0
	D               when (W='0' and ADR_A = ADR_W) else -- D si access simultané
	REGS(conv_integer(ADR_A));-- sinon registre

QB <= 
	(others => 'X') when is_x(ADR_B) else -- X si adresse invalide
	(others => '0') when conv_integer(ADR_B)=0 else -- 0 si R0
	D               when (W='0' and ADR_B = ADR_W) else -- D si access simultané
	REGS(conv_integer(ADR_B));-- sinon registre

P_WRITE: process(CLK)
begin
	if (CLK'event and CLK=ACTIVE_FRONT) then-- test du front actif d'horloge
		if RST='0' then -- test du reset (actif a l'etat bas)
			REGS <= (others => conv_std_logic_vector(0,DBUS_WIDTH));
		else-- test si ecriture dans le registre
			if ((W='0') and (conv_integer(ADR_W) /= 0)) then
				REGS(conv_integer(ADR_W)) <= D;
			end if;
		end if;
	end if;
end process P_WRITE;

end behavior;
```

### [risc](risc.vhd)

```
library IEEE;

-- Definition des portee d'utilisation
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
use WORK.cpu_package.all;

-- Definition de l'entite
entity risc is
	generic(
		IFILE : string := "";  -- cache instruction
		DFILE : string := ""   -- cache donnees
	);
	port(
		RST : in std_logic; -- actifs a l'etat bas
		CLK : in std_logic
	);
end risc;

-- Definition de l'architecture du banc de registres
architecture behavior of risc is
	-- Registres du pipeline
	signal reg_EI_DI     : EI_DI;     -- registre pipeline EI/DI
	signal reg_DI_EX     : DI_EX;     -- registre pipeline DI/EX
	signal reg_EX_ME     : EX_ME;     -- registre pipeline EX/MEM
	signal reg_ME_ER     : ME_ER;     -- registre pipeline MEM/ER
	signal reg_PC        : ADDR;      -- compteur programme format octet
	-- Ressources des etages
	signal ei_pc_mux     : MUX_PC_SRC;-- doit ont CP+4 ou CP=BRANCH ou CP=PC+IMM
	signal ei_pc_next    : PC;        -- pointeur sur prochaine instruction
	signal di_pc_branch  : PC;        -- IMM+PC
	signal ei_pc_jump    : PC;        -- JADDR
	signal ei_inst       : INST;      -- instruction en sortie du cache instruction
	signal di_ctrl_di    : ctrlDI;    -- signaux de controle de l'etage DI
	signal di_ctrl_ex    : ctrlEX;    -- signaux de controle de l'etage EX
	signal di_ctrl_me    : ctrlME;    -- signaux de controle de l'etage ME
	signal di_ctrl_er    : ctrlER;    -- signaux de controle de l'etage ER
	signal di_imm_ext    : DATA;      -- valeur immediate etendue
	signal di_qa         : DATA;      -- sortie QA du banc de registres
	signal di_qb         : DATA;      -- sortie QB du banc de registres
	signal ex_alu_a      : DATA;      -- ALU Entée A
	signal ex_alu_b      : DATA;      -- ALU Entée B
	signal me_data       : DATA;      -- sortie du banc memoire (dcache)
	signal er_regd       : DATA;      -- donnees a ecrire dans le banc de registre
	signal er_adrw       : REGS;      -- adresse du registre a ecrire dans le banc

begin

-- ===============================================================
-- === Etage EI ==================================================
-- ===============================================================

-- instanciation et mapping du composant cache instruction
icache : entity work.memory(behavior)
generic map (
	DBUS_WIDTH=>CPU_DATA_WIDTH,
	ABUS_WIDTH=>CPU_ADR_WIDTH,
	MEM_SIZE=>L1_ISIZE,
	ACTIVE_FRONT=>L1_FRONT,
	FILENAME=>IFILE )
port map (
	RST=>RST,
	CLK=>CLK,
	RW=>'0',
	DS=>MEM_32,
	SIGN=>'0',
	AS=>'1',
	Ready=>open,
	Berr=>open,
	ADR=>reg_PC,
	D=>(others => '0'),
	Q=>ei_inst
);

-- Affectations dans le domaine combinatoire de l'etage EI

-- Incrementation du PC (format mot)
with(ei_pc_mux) select ei_pc_next <= 
	reg_PC(PC'range)+1 when PC_NEXT, -- "+" surchargé par l'entity adder
	di_pc_branch       when PC_BRANCH,-- BEQ,BNE,BLEZ,BGTZ,BLTZ,BGEZ,BLTZAL,BGEZAL
	ei_pc_jump         when PC_JUMP,  -- J/JAL
	di_qa(PC'range)    when PC_JUMP_R;-- JR/JALR

-- Process Etage Extraction de l'instruction et mise a jour de l'etage EI/DI et du PC
EI: process(CLK,RST)
begin
	if (RST='0') then -- test du reset
		reg_PC <= PC_DEFL;-- reset du PC
	elsif (CLK'event and CLK=CPU_WR_FRONT) then -- test du front actif d'horloge
		reg_PC(PC'range)  <= ei_pc_next;-- Mise a jour PC. TODO : only if halt=0 or MEM_flush='1' or EX_flush='1'
		reg_EI_DI.pc_next <= ei_pc_next;-- Mise a jour du registre inter-etage EI/DI
		reg_EI_DI.inst    <= ei_inst;   -- TODO if ME or EX flush : ZERO
	end if;
end process EI;

-- ===============================================================
-- === Etage DI ==================================================
-- ===============================================================

-- instantiation et mapping du composant registres
r : entity work.registres(behavior)
	generic map ( 
		DBUS_WIDTH=>CPU_DATA_WIDTH,
		ABUS_WIDTH=>REG_WIDTH,
		ACTIVE_FRONT=>REG_FRONT
	)
	port map (
		CLK=>CLK,
		W=>reg_ME_ER.er_ctrl.REGS_WE,
		RST=>RST,
		D=>er_regd,
		ADR_A=>reg_EI_DI.inst(RS'range),
		ADR_B=>reg_EI_DI.inst(RT'range),
		ADR_W=>er_adrw,
		QA=>di_qa,
		QB=>di_qb
	);
------------------------------------------------------------------
-- Affectations dans le domaine combinatoire de l'etage DI
-- 

-- Calcul de l'extension de la valeur immediate
ei_pc_jump <= reg_EI_DI.inst(JADR'range);
di_imm_ext(IMM'range) <= reg_EI_DI.inst(IMM'range);
di_imm_ext(DATA'high downto IMM'high+1) <=
	(others => '0') when di_ctrl_di.signed_ext=IMM_UNSIGNED else
	(others => reg_EI_DI.inst(IMM'high));
di_pc_branch <= reg_DI_EX.pc_next + reg_DI_EX.imm_ext(PC_WIDTH-1 downto 0);
-- Appel de la procedure control
UC: control(
	reg_EI_DI.inst(OPCODE'range),
	reg_EI_DI.inst(FCODE'range),
	reg_EI_DI.inst(BCODE'range),
	di_ctrl_di,
	di_ctrl_ex,
	di_ctrl_me,
	di_ctrl_er
);

------------------------------------------------------------------
-- Process Etage Extraction de l'instruction et mise a jour de l'etage DI/EX
DI: process(CLK,RST)
begin
	-- test du reset
	if (RST='0') then
		-- reset des controle du pipeline
		reg_DI_EX.ex_ctrl  <= EX_DEFL;
		reg_DI_EX.me_ctrl  <= ME_DEFL;
		reg_DI_EX.er_ctrl  <= ER_DEFL;
	-- test du front actif d'horloge
	elsif (CLK'event and CLK=CPU_WR_FRONT) then
		-- Mise a jour du registre inter-etage DI/EX
		reg_DI_EX.pc_next  <= reg_EI_DI.pc_next;
		reg_DI_EX.rs       <= reg_EI_DI.inst(RS'range);
		reg_DI_EX.rt       <= reg_EI_DI.inst(RT'range);
		reg_DI_EX.rd       <= reg_EI_DI.inst(RD'range);
		reg_DI_EX.val_dec  <= reg_EI_DI.inst(VALDEC'range);
		reg_DI_EX.imm_ext  <= di_imm_ext;
		reg_DI_EX.jump_adr <= reg_EI_DI.inst(JADR'range);
		reg_DI_EX.rs_read  <= di_qa;
		reg_DI_EX.rt_read  <= di_qb;
		-- Mise a jour des signaux de controle
		reg_DI_EX.ex_ctrl  <= di_ctrl_ex;--TODO EX_DEFL when EI/ME/EX halt
		reg_DI_EX.me_ctrl  <= di_ctrl_me;--TODO ME_DEFL when EI/ME/EX halt
		reg_DI_EX.er_ctrl  <= di_ctrl_er;--TODO ER_DEFL when EI/ME/EX halt
	end if;
end process DI;

-- ===============================================================
-- === Etage EX ==================================================
-- ===============================================================
reg_DI_EX.val_ext <= conv_std_logic_vector(conv_integer(reg_DI_EX.val_dec),DATA'length);

with(reg_DI_EX.ex_ctrl.ALU_SRCA) select ex_alu_a <= 
	reg_DI_EX.rs_read when REGS_QA,
	reg_DI_EX.rt_read when REGS_QB, -- LSL/LSR
	reg_DI_EX.imm_ext when IMMD; -- LUI only

with(reg_DI_EX.ex_ctrl.ALU_SRCB) select ex_alu_b <= 
	reg_DI_EX.rt_read when REGS_QB,
	reg_DI_EX.imm_ext when IMMD,
	reg_DI_EX.val_ext when VAL_DEC,
	VAL16             when IMM_16,
	ZERO              when IMM_0;

alu(ex_alu_a, ex_alu_b,-- in
	reg_EX_ME.ual_S, -- out
	reg_EX_ME.ual_N, reg_EX_ME.ual_V,reg_EX_ME.ual_Z, reg_EX_ME.ual_C, -- out
	reg_DI_EX.ex_ctrl.ALU_SIGNED,reg_DI_EX.ex_ctrl.ALU_OP -- param
);

ei_pc_mux <= PC_BRANCH when
   ((reg_EX_ME.me_ctrl.BRANCH=B_NE) and (not(reg_EX_ME.ual_Z='1')                                                    ))
or ((reg_EX_ME.me_ctrl.BRANCH=B_EQ) and (   (reg_EX_ME.ual_Z='1')                                                    ))
or ((reg_EX_ME.me_ctrl.BRANCH=B_LE) and (   (reg_EX_ME.ual_Z='1') or     (reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
or ((reg_EX_ME.me_ctrl.BRANCH=B_LT) and (not(reg_EX_ME.ual_Z='1') and    (reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
or ((reg_EX_ME.me_ctrl.BRANCH=B_GT) and (not(reg_EX_ME.ual_Z='1') and not(reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
or ((reg_EX_ME.me_ctrl.BRANCH=B_GE) and (   (reg_EX_ME.ual_Z='1') or  not(reg_EX_ME.ual_V='1' xor reg_EX_ME.ual_N='1')))
else PC_JUMP   when di_ctrl_di.JUMP_IMM
else PC_JUMP_R when di_ctrl_di.JUMP_REG
else PC_NEXT;

with(reg_DI_EX.ex_ctrl.REG_DST) select reg_EX_ME.reg_dst <= 
	reg_DI_EX.rd when REG_RD,
	reg_DI_EX.rt when REG_RT,
	"11111"      when REG_31;-- *AL conv_std_logic_vector(1,ABUS_WIDTH)

EX: process(CLK,RST)
begin
	if (RST='0') then-- test du reset
		reg_EX_ME.me_ctrl <= ME_DEFL;-- reset des controle du pipeline
		reg_EX_ME.er_ctrl <= ER_DEFL;
	elsif (CLK'event and CLK=CPU_WR_FRONT) then -- test du front actif d'horloge
		reg_EX_ME.pc_next  <= reg_DI_EX.pc_next;
		reg_EX_ME.rt_read  <= reg_DI_EX.rt_read;
		reg_EX_ME.me_ctrl  <= reg_DI_EX.me_ctrl;
		reg_EX_ME.er_ctrl  <= reg_DI_EX.er_ctrl;
	end if;
end process EX;



-- ===============================================================
-- === Etage ME ==================================================
-- ===============================================================

-- instanciation et mapping du composant cache de donnees
dcache : entity work.memory(behavior)
generic map (
	DBUS_WIDTH=>CPU_DATA_WIDTH,
	ABUS_WIDTH=>CPU_ADR_WIDTH,
	MEM_SIZE=>L1_DSIZE,
	ACTIVE_FRONT=>L1_FRONT,
	FILENAME=>DFILE
)
port map(
	RST=>RST,
	CLK=>CLK,
	SIGN=>reg_EX_ME.me_ctrl.DC_SIGNED,
	DS=>reg_EX_ME.me_ctrl.DC_DS,
	RW=>reg_EX_ME.me_ctrl.DC_RW,
	AS=>reg_EX_ME.me_ctrl.DC_AS,
	Ready=>open,
	Berr=>open,
	ADR=>reg_EX_ME.ual_S,
	D=>reg_EX_ME.rt_read,
	Q=>me_data
);

ME: process(CLK,RST)
begin
	if (RST='0') then -- test du reset
		reg_ME_ER.er_ctrl <= ER_DEFL;-- reset des controle du pipeline
	elsif (CLK'event and CLK=CPU_WR_FRONT) then -- test du front actif d'horloge
		reg_ME_ER.mem_Q     <= me_data;-- sortie memoire
		reg_ME_ER.er_ctrl   <= reg_EX_ME.er_ctrl;-- propa signaux de controle
		reg_ME_ER.pc_next   <= reg_EX_ME.pc_next;-- propa cp incremente
		reg_ME_ER.ual_S     <= reg_EX_ME.ual_S;  -- propa resultat ual
		reg_ME_ER.reg_dst   <= reg_EX_ME.reg_dst;-- propa registre destination
	end if;
end process ME;

-- ===============================================================
-- === Etage ER ==================================================
-- ===============================================================

ER: process(CLK,RST)
begin
end process ER;

er_adrw<=reg_ME_ER.reg_dst;
with(reg_ME_ER.er_ctrl.REGS_SRCD) select er_regd <= 
	reg_ME_ER.mem_Q        when MEM_Q,
	reg_ME_ER.ual_S        when ALU_S,
	conv_std_logic_vector(conv_integer(reg_ME_ER.pc_next), DATA'length)      when NextPC; --TODO find a better one (maybe using &"00" ?)
end behavior;
```

</div>
<script src="http://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"></script>
<script>var t=document.getElementById('t');t.innerHTML=marked(t.innerHTML.replace(/&gt;/g,'>').replace(/&lt;/g,'<'))
.replace(/<table/g,'<table class="table table-bordered table-striped"')
.replace(/<img/g,'<img class="img-responsive"');</script>
<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
</body></html>
